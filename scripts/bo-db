#!/usr/bin/env python
# -*- coding: utf8 -*-

from __future__ import print_function
import sys
import datetime
import math

import pytz

from optparse import OptionParser, SUPPRESS_HELP

import shapely.geometry
import shapely.wkt

import blitzortung.config
import blitzortung.geom

DATE_FORMAT = '%Y%m%d'
TIME_FORMAT = '%H%M'
SECONDS_FORMAT = '%S'


def parse_time(date_string, time_string, description, is_end_time=False):
    try:
        has_seconds = len(time_string) > 4
        tmp_date = datetime.datetime.strptime(date_string, DATE_FORMAT).date()
        tmp_time = datetime.datetime.strptime(time_string,
                                              TIME_FORMAT + (SECONDS_FORMAT if has_seconds else '')).time()
        parsed_time = tz.localize(datetime.datetime.combine(tmp_date, tmp_time), is_dst=True)
        if is_end_time:
            parsed_time += (datetime.timedelta(seconds=1) if has_seconds else datetime.timedelta(minutes=1))
        return parsed_time
    except:
        print("parse error in %s" % description)
        sys.exit(5)


def prepare_raster_if_applicable(options, area):
    if options.raster is not None or options.xraster is not None or options.yraster is not None:

        if options.raster is not None:
            raster_x = options.raster
            raster_y = options.raster

        if options.xraster is not None:
            raster_x = options.xraster
            if options.yraster is None and options.raster is None:
                raster_y = raster_x

        if options.yraster is not None:
            raster_y = options.yraster
            if options.xraster is None and options.raster is None:
                raster_x = raster_y

        if options.area is None:
            print("raster options requires declaration of envelope area")
            sys.exit(1)
        env = area.envelope.bounds
        return blitzortung.geom.Raster(env[0], env[2], env[1], env[3], raster_x, raster_y, options.srid)


tz = pytz.timezone('UTC')
end_time = datetime.datetime.utcnow().replace(tzinfo=tz)
start_time = end_time - datetime.timedelta(hours=1)
end_time -= datetime.timedelta(minutes=1)

parser = OptionParser()

parser.add_option("--startdate", dest="startdate", default="default",
                  help="start date for data retrieval", type="string")

parser.add_option("--starttime", dest="starttime", default="default",
                  help="start time for data retrieval", type="string")

parser.add_option("--enddate", dest="enddate", default="default",
                  help="end date for data retrieval", type="string")

parser.add_option("--endtime", dest="endtime", default="default",
                  help="end time for data retrieval", type="string")

parser.add_option("--area", dest="area",
                  help="area for which strokes are selected", type="string")

parser.add_option("--tz", dest="tz", default=str(tz),
                  help="used timezone", type="string")

parser.add_option("--useenv", dest="useenv", default=False, action="store_true",
                  help="use envelope of given area for query")

parser.add_option("--srid", dest="srid", default=blitzortung.geom.Geometry.DefaultSrid,
                  help="srid for query area and results", type="int")

parser.add_option("--precision", dest="precision", default=4,
                  help="precision of coordinates", type="int")

parser.add_option("--raster", dest="raster",
                  help="raster width", type="float")

parser.add_option("--x-raster", dest="xraster",
                  help="raster x width", type="float")

parser.add_option("--y-raster", dest="yraster",
                  help="raster y width", type="float")

parser.add_option("--map", dest="map", action="store_true",
                  help="show ascii map instead of numerical raster")

(options, args) = parser.parse_args()

try:
    tz = pytz.timezone(options.tz)
except:
    print('parse error in timezone "' + options.tz + '"')
    sys.exit(1)

start_time = start_time.astimezone(tz)
end_time = end_time.astimezone(tz)

if options.startdate == 'default':
    options.startdate = start_time.strftime(DATE_FORMAT)
if options.starttime == 'default':
    options.starttime = start_time.strftime(TIME_FORMAT)
if options.enddate == 'default':
    options.enddate = end_time.strftime(DATE_FORMAT)
if options.endtime == 'default':
    options.endtime = end_time.strftime(TIME_FORMAT)

start_time = parse_time(options.startdate, options.starttime, "starttime")
end_time = parse_time(options.enddate, options.endtime, "endtime", is_end_time=True)

area = None
if options.area:
    try:
        area = shapely.wkt.loads(options.area)
    except:
        print('parse error in area "' + options.area + '"')

    if options.useenv:
        area = area.envelope

# open stroke database
stroke_db = blitzortung.db.stroke()

# set data parameters
stroke_db.set_srid(options.srid)
stroke_db.set_timezone(tz)

# set time range 
time_range = blitzortung.db.query.TimeInterval(start_time, end_time)

# set query parameters
limit = blitzortung.db.query.Limit(5)
order = blitzortung.db.query.Order('timestamp')

raster = prepare_raster_if_applicable(options, area)

# start timer for database select
timer = blitzortung.util.Timer()

if raster:
    raster_result = stroke_db.select_raster(raster, time_range)

    select_time = timer.lap()

    print(raster_result.to_map() if options.map else raster_result.to_arcgrid())
    sys.stderr.write('received raster data in %.3f seconds\n' % (select_time))

else:
    strokes = stroke_db.select(time_range, area, order)

    select_time = timer.lap()

    precision_factor = math.pow(10.0, options.precision)

    for stroke in strokes:
        location_x = round(stroke.get_x() * precision_factor) / precision_factor
        location_y = round(stroke.get_y() * precision_factor) / precision_factor
        print(str(stroke))

    sys.stderr.write('received %d strokes in %.3f seconds\n' % (len(strokes), select_time))


